# ================================
# YAF 容器 Dockerfile 
# ================================

# ================================
# 1. Go 编译阶段
# ================================
FROM --platform=$BUILDPLATFORM golang:1.21-alpine AS go-builder

ARG TARGETOS
ARG TARGETARCH
ARG BUILDPLATFORM

WORKDIR /build

# ===== 编译 config-agent =====
WORKDIR /build/config-agent
COPY config-agent/go.mod config-agent/go.sum ./
RUN go mod download
COPY config-agent/ ./
RUN set -eux; \
    CGO_ENABLED=0 GOOS=${TARGETOS} GOARCH=${TARGETARCH} \
    go build -ldflags="-w -s" -o /build/yaf-config-agent ./cmd/agent && \
    chmod +x /build/yaf-config-agent

# ===== 编译 processor =====
WORKDIR /build/yaf-processor
COPY yaf-processor/go.mod yaf-processor/go.sum ./
RUN go mod download
COPY yaf-processor/ ./
RUN set -eux; \
    CGO_ENABLED=0 GOOS=${TARGETOS} GOARCH=${TARGETARCH} \
    go build -ldflags="-w -s" -o /build/processor ./cmd/processor && \
    chmod +x /build/processor

# ================================
# 2. 构建阶段
# ================================
FROM debian:bookworm-slim AS builder

ARG APT_PROXY
ARG FIXBUF_VERSION=3.0.0.alpha2
ARG YAF_VERSION=3.0.0.alpha4
ARG SM_VERSION=2.0.0.alpha3

ENV DEBIAN_FRONTEND=noninteractive
ENV PKG_CONFIG_PATH=/usr/local/lib/pkgconfig

# 使用阿里云镜像
RUN set -eux; \
    rm -f /etc/apt/sources.list.d/debian.sources || true; \
    echo "deb http://mirrors.aliyun.com/debian bookworm main contrib non-free non-free-firmware" > /etc/apt/sources.list; \
    echo "deb http://mirrors.aliyun.com/debian bookworm-updates main contrib non-free non-free-firmware" >> /etc/apt/sources.list; \
    echo "deb http://mirrors.aliyun.com/debian-security bookworm-security main contrib non-free non-free-firmware" >> /etc/apt/sources.list; \
    apt-get update && apt-get install -y --no-install-recommends \
        build-essential pkg-config wget curl ca-certificates \
        libglib2.0-dev libpcap-dev libpcre3-dev zlib1g-dev libssl-dev liblua5.3-dev; \
    rm -rf /var/lib/apt/lists/*

WORKDIR /tmp

# 编译 libfixbuf
RUN HTTP_PROXY=${APT_PROXY} HTTPS_PROXY=${APT_PROXY} \
    curl -fSL "https://tools.netsa.cert.org/releases/libfixbuf-${FIXBUF_VERSION}.tar.gz" -o libfixbuf.tar.gz && \
    tar xzf libfixbuf.tar.gz && cd "libfixbuf-${FIXBUF_VERSION}" && \
    ./configure --disable-tools && make -j"$(nproc)" && make install && ldconfig && \
    cd /tmp && rm -rf "libfixbuf-${FIXBUF_VERSION}" libfixbuf.tar.gz

# 编译 YAF
RUN HTTP_PROXY=${APT_PROXY} HTTPS_PROXY=${APT_PROXY} \
    curl -fSL "https://tools.netsa.cert.org/releases/yaf-${YAF_VERSION}.tar.gz" -o yaf.tar.gz && \
    tar xzf yaf.tar.gz && cd "yaf-${YAF_VERSION}" && \
    ./configure --enable-applabel --enable-dpi && \
    make -j"$(nproc)" && make install && ldconfig && \
    cd /tmp && rm -rf "yaf-${YAF_VERSION}" yaf.tar.gz

# 编译 super_mediator
RUN HTTP_PROXY=${APT_PROXY} HTTPS_PROXY=${APT_PROXY} \
    curl -fSL "https://tools.netsa.cert.org/releases/super_mediator-${SM_VERSION}.tar.gz" -o sm.tar.gz && \
    tar xzf sm.tar.gz && cd "super_mediator-${SM_VERSION}" && \
    ./configure --with-mysql=no && \
    make -j"$(nproc)" && make install && ldconfig && \
    cd /tmp && rm -rf "super_mediator-${SM_VERSION}" sm.tar.gz

# ================================
# 3. 运行阶段
# ================================
FROM debian:bookworm-slim AS runtime

ENV DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Shanghai

# 安装运行时依赖
RUN set -eux; \
    rm -f /etc/apt/sources.list.d/debian.sources || true; \
    echo "deb http://mirrors.aliyun.com/debian bookworm main contrib non-free non-free-firmware" > /etc/apt/sources.list; \
    echo "deb http://mirrors.aliyun.com/debian bookworm-updates main contrib non-free non-free-firmware" >> /etc/apt/sources.list; \
    echo "deb http://mirrors.aliyun.com/debian-security bookworm-security main contrib non-free non-free-firmware" >> /etc/apt/sources.list; \
    apt-get update && apt-get install -y --no-install-recommends \
        ca-certificates libglib2.0-0 libpcap0.8 libpcre3 zlib1g libssl3 liblua5.3-0 \
        bash procps tcpdump netcat-traditional iproute2 net-tools dnsutils psmisc vim-tiny less \
        lsof supervisor tzdata && \
    ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone && dpkg-reconfigure -f noninteractive tzdata && \
    rm -rf /var/lib/apt/lists/*

# 复制文件
COPY --from=builder /usr/local/ /usr/local/
COPY --from=go-builder /build/yaf-config-agent /usr/local/bin/yaf-config-agent
COPY --from=go-builder /build/processor /usr/local/bin/processor

# 配置库路径
RUN echo "/usr/local/lib" > /etc/ld.so.conf.d/usr-local.conf && \
    echo "/usr/local/lib64" >> /etc/ld.so.conf.d/usr-local.conf && \
    ldconfig
ENV LD_LIBRARY_PATH=/usr/local/lib:/usr/local/lib64

# 创建用户和目录
RUN groupadd -r yaf && \
    useradd -r -g yaf -d /var/lib/yaf -s /usr/sbin/nologin yaf && \
    mkdir -p /data /etc/yaf /var/log/supervisor /var/run/supervisor /opt/yaf && \
    chown -R yaf:yaf /data /var/log/supervisor /var/run/supervisor /opt/yaf && \
    chown -R root:root /etc/yaf && \
    chmod 755 /var/run/supervisor

# YAF 配置文件
RUN cat >/opt/yaf/yaf.init <<'EOF'
-- ========= YAF 基础配置 =========
input = {
  type = "pcap",
  inf  = "eth0",
  export_interface = true,
}
output = {
  host     = "127.0.0.1",
  port     = "18000",
  protocol = "tcp",
}
decode = {
  ip4_only = false,
  ip6_only = false,
  nofrag   = false,
}
export = {
  silk       = true,
  uniflow    = true,
  flow_stats = true,
  mac        = true,
}
idle_timeout   = 60
active_timeout = 60
filter = "ip and not port 22"
applabel   = true
dpi        = false
maxpayload = 1024
maxexport  = maxpayload
udp_payload = true
stats       = 300
EOF

RUN ln -sf /opt/yaf/yaf.init /etc/yaf/yaf.init && \
    chown -R yaf:yaf /opt/yaf

# === YAF 启动脚本：等待 super_mediator 监听后再启动 ===
RUN cat >/usr/local/bin/start_yaf.sh <<'EOF'
#!/usr/bin/env bash
set -eu

YAF_CONFIG_FILE="${YAF_CONFIG_FILE:-/etc/yaf/yaf.init}"
SM_HOST="${SM_HOST:-127.0.0.1}"
SM_PORT="${SM_LISTEN_PORT:-18000}"

log() { echo "[$(date '+%F %T')] [YAF] $*" >&2; }

# 检查配置文件
if [ ! -f "${YAF_CONFIG_FILE}" ]; then
  log "ERROR: Config file not found: ${YAF_CONFIG_FILE}"
  exit 1
fi

# 等待 super_mediator 启动
log "Waiting for super_mediator ${SM_HOST}:${SM_PORT} to be ready..."
max_wait=60
waited=0

while [ $waited -lt $max_wait ]; do
  if nc -z "${SM_HOST}" "${SM_PORT}" >/dev/null 2>&1; then
    log "super_mediator is UP and ready"
    break
  fi
  if [ $((waited % 10)) -eq 0 ] && [ $waited -gt 0 ]; then
    log "Still waiting... (${waited}/${max_wait}s)"
  fi
  sleep 1
  waited=$((waited + 1))
done

if [ $waited -ge $max_wait ]; then
  log "WARN: super_mediator not ready after ${max_wait}s, starting YAF anyway"
fi

log "Starting YAF with config: ${YAF_CONFIG_FILE}"
exec /usr/local/bin/yaf --config "${YAF_CONFIG_FILE}" "$@"
EOF

# === Pipeline 启动脚本：优化端口检查和清理逻辑 ===
RUN cat >/usr/local/bin/start_pipeline.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

SM_PORT="${SM_LISTEN_PORT:-18000}"
YAF_CONFIG="${YAF_CONFIG_FILE:-/etc/yaf/yaf.init}"
FIELDS="${SM_FIELDS:-flowStartMilliseconds,flowEndMilliseconds,sourceIPv4Address,destinationIPv4Address,sourceTransportPort,destinationTransportPort,protocolIdentifier,silkAppLabel}"

log() { echo "[$(date '+%F %T')] [PIPELINE] $*" >&2; }

# 检查端口是否处于 LISTEN 状态
is_port_listening() {
  local port=$1
  ss -ltn 2>/dev/null | awk '{print $4}' | grep -qE "[:.]${port}$"
}

# 清理残留进程
cleanup_leftover_processes() {
  local cleaned=0
  
  # 清理 super_mediator 进程
  if command -v pgrep >/dev/null 2>&1; then
    local pids=$(pgrep -f "super_mediator" 2>/dev/null || true)
    if [ -n "$pids" ]; then
      log "Found leftover super_mediator processes: $pids, killing..."
      echo "$pids" | xargs -r kill -TERM 2>/dev/null || true
      sleep 2
      local pids_alive=$(pgrep -f "super_mediator" 2>/dev/null || true)
      if [ -n "$pids_alive" ]; then
        log "Force killing remaining processes: $pids_alive"
        echo "$pids_alive" | xargs -r kill -KILL 2>/dev/null || true
        sleep 1
      fi
      cleaned=1
    fi
  fi
  
  # 清理 processor 进程
  if command -v pgrep >/dev/null 2>&1; then
    local pids=$(pgrep -f "processor.*-config.*${YAF_CONFIG}" 2>/dev/null || true)
    if [ -n "$pids" ]; then
      log "Found leftover processor processes: $pids, killing..."
      echo "$pids" | xargs -r kill -TERM 2>/dev/null || true
      sleep 1
      local pids_alive=$(pgrep -f "processor.*-config.*${YAF_CONFIG}" 2>/dev/null || true)
      if [ -n "$pids_alive" ]; then
        log "Force killing remaining processor processes: $pids_alive"
        echo "$pids_alive" | xargs -r kill -KILL 2>/dev/null || true
        sleep 1
      fi
      cleaned=1
    fi
  fi
  
  return $cleaned
}

# 等待端口释放（只检查 LISTEN 状态，忽略 TIME_WAIT）
wait_for_port_release() {
  local port=$1
  local max_wait=${2:-30}
  local waited=0
  
  log "Checking port ${port} LISTEN availability..."
  
  while [ $waited -lt $max_wait ]; do
    if is_port_listening "$port"; then
      log "Port ${port} is BUSY (LISTEN), waiting... (${waited}/${max_wait}s)"
      sleep 1
      waited=$((waited + 1))
    else
      log "Port ${port} is FREE (no LISTEN)."
      return 0
    fi
  done
  
  log "WARN: Port ${port} still LISTEN after ${max_wait}s, will try to start anyway"
  return 0
}

# 确保端口可用（多次检查，避免竞态）
ensure_port_available() {
  local port=$1
  local retries=0
  local max_retries=5
  
  while [ $retries -lt $max_retries ]; do
    if is_port_listening "$port"; then
      log "Port ${port} still LISTEN, waiting 2s... (retry ${retries}/${max_retries})"
      sleep 2
      retries=$((retries + 1))
    else
      # 额外等待 2 秒，确保 TIME_WAIT 状态完全释放
      log "Port ${port} is available, waiting 2s for TIME_WAIT to clear..."
      sleep 2
      # 再次确认
      if ! is_port_listening "$port"; then
        log "Port ${port} confirmed available"
        return 0
      else
        log "Port ${port} became busy again, retrying..."
        retries=$((retries + 1))
      fi
    fi
  done
  
  log "ERROR: Port ${port} still not available after ${max_retries} retries"
  return 1
}

# 主流程
main() {
  # 1. 清理残留进程
  if cleanup_leftover_processes; then
    log "Cleaned up leftover processes, waiting for port release..."
    sleep 2
  fi
  
  # 2. 等待端口释放
  wait_for_port_release "${SM_PORT}" 30
  
  # 3. 确保端口可用
  if ! ensure_port_available "${SM_PORT}"; then
    log "ERROR: Cannot start super_mediator, port ${SM_PORT} is not available"
    exit 1
  fi
  
  # 4. 启动 super_mediator 和 processor
  log "Starting super_mediator on 127.0.0.1:${SM_PORT}"
  
  # 临时禁用 pipefail，以便正确处理管道退出状态
  set +o pipefail
  
  # 启动管道：super_mediator 输出到 processor
  /usr/local/bin/super_mediator \
    --ipfix-input=tcp \
    --ipfix-port="${SM_PORT}" \
    --output-mode=TEXT \
    --print-headers \
    --out=- \
    --fields="${FIELDS}" \
    127.0.0.1 2>&1 | \
  /usr/local/bin/processor -config "${YAF_CONFIG}" -data-dir /data
  
  # 获取退出状态
  local processor_exit=$?
  local sm_exit=${PIPESTATUS[0]}
  
  set -o pipefail
  
  # 记录退出状态
  log "super_mediator exit code: ${sm_exit}, processor exit code: ${processor_exit}"
  
  # processor 正常退出（EOF）时返回 0，这是正常的
  # 只有当 processor 异常退出（非 0）或 super_mediator 异常退出时才返回错误
  if [ $processor_exit -ne 0 ]; then
    log "ERROR: processor exited with code $processor_exit"
    exit $processor_exit
  fi
  
  if [ $sm_exit -ne 0 ]; then
    log "ERROR: super_mediator exited with code $sm_exit"
    exit $sm_exit
  fi
  
  # 正常退出（EOF）- 返回 0 让 supervisor 知道这是正常退出
  # supervisor 配置了 exitcodes=0,1，所以 exit 0 会被视为正常退出
  log "Pipeline exited normally (EOF), supervisor will restart if needed"
  exit 0
}

# 设置退出清理
cleanup_on_exit() {
  log "Received exit signal, cleaning up..."
  cleanup_leftover_processes || true
}
trap cleanup_on_exit TERM INT EXIT

# 执行主流程
main "$@"
EOF

# 修复 Windows CRLF 行尾符问题，确保脚本使用 Unix LF 格式
RUN sed -i 's/\r$//' /usr/local/bin/start_yaf.sh /usr/local/bin/start_pipeline.sh && \
    chmod +x /usr/local/bin/start_yaf.sh /usr/local/bin/start_pipeline.sh

# === Supervisord 配置：pipeline 先启动，yaf 后启动 ===
# 关键优化：
# 1. pipeline priority=10 最先启动，startsecs=8 确保 super_mediator 监听就绪
# 2. yaf priority=20，等 pipeline 就绪后再连接
# 3. config-agent priority=5 最先启动，但它不影响其他进程
RUN cat >/etc/supervisor/supervisord.conf <<'EOF'
[unix_http_server]
file=/var/run/supervisor/supervisor.sock
chmod=0700

[supervisord]
nodaemon=true
logfile=/dev/stdout
logfile_maxbytes=0
pidfile=/var/run/supervisor/supervisord.pid
user=root

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///var/run/supervisor/supervisor.sock

[program:config-agent]
command=/usr/local/bin/yaf-config-agent
user=root
priority=5
autorestart=true
startsecs=3
startretries=10
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stdout
stderr_logfile_maxbytes=0

[program:pipeline]
command=/bin/bash /usr/local/bin/start_pipeline.sh
user=yaf
priority=10
autorestart=true
startsecs=8
startretries=10
stopwaitsecs=30
stopasgroup=true
killasgroup=true
exitcodes=0
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stdout
stderr_logfile_maxbytes=0

[program:yaf]
command=/bin/bash /usr/local/bin/start_yaf.sh
user=root
priority=20
autorestart=true
startsecs=3
startretries=30
stopwaitsecs=10
stdout_logfile=/var/log/supervisor/yaf.log
stdout_logfile_maxbytes=20MB
stderr_logfile=/dev/stdout
stderr_logfile_maxbytes=0
EOF

WORKDIR /opt/yaf
ENV ZK_SERVERS=zookeeper:2181 \
    YAF_CLUSTER=default \
    YAF_NODE_ID=node-1 \
    YAF_CONFIG_PATH=/etc/yaf/yaf.init \
    YAF_INTERFACE=eth0 \
    SM_LISTEN_PORT=18000 \
    SM_HOST=127.0.0.1

ENTRYPOINT ["/usr/bin/supervisord", "-c", "/etc/supervisor/supervisord.conf"]
CMD []
